import{_ as e,o as p,c as a,Q as s}from"./chunks/framework.e5c343f4.js";const t="/assets/image-20240104233034090.48d70878.png",r="/assets/image-20240104232731235.9aeefe4d.png",y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"course/3- JS Array+Object.md","filePath":"course/3- JS Array+Object.md"}'),i={name:"course/3- JS Array+Object.md"},l=s('<p>var 不建议</p><p>let const</p><img src="'+t+'" alt="image-20240104233034090" style="zoom:50%;"><p>工程建议全等于</p><p>比赛建议等于</p><h2 id="string" tabindex="-1">String <a class="header-anchor" href="#string" aria-label="Permalink to &quot;String&quot;">​</a></h2><p>split join</p><p>replace replaceAll</p><img src="'+r+'" alt="image-20240104232731235" style="zoom:50%;"><p>indexOf lastIndexOf</p><h2 id="array" tabindex="-1">Array <a class="header-anchor" href="#array" aria-label="Permalink to &quot;Array&quot;">​</a></h2><p>常用方法</p><p>改变数组本身：</p><p>push pop unshift shift</p><p>reverse sort splice</p><p>不改变：</p><p>concat join slice indexOf</p><p>遍历：</p><p>forEach map filter</p><p>every some</p><p>find reduce</p><p>includes</p><p>for...in（不建议） for ... of</p><p>更推荐使用不改变本身的</p><p>数组中添加元素：</p><ol><li>使用...扩展运算符</li><li>push</li></ol><p>删除元素：</p><p>splice</p><p>filter((item)=&gt;item.id!== del_id)</p><h3 id="object" tabindex="-1">Object <a class="header-anchor" href="#object" aria-label="Permalink to &quot;Object&quot;">​</a></h3><p>const person = { first: &#39;Albert&#39;, last: &#39;Einstein&#39;, year: 1879, passed: 1955 };</p><p>解构[]和{}</p><p>取值：person.first person[year]</p><p>遍历</p><p>keys() values() entries()</p><p>for...in</p><p>mdn推荐你for in用在对象，for of用在数组</p><p>for (const [key, value] of Object.entries(userList)) {</p><p>练习</p><ol><li><p>常用方法</p><p>const inventors = [ { first: &#39;Albert&#39;, last: &#39;Einstein&#39;, year: 1879, passed: 1955 }, { first: &#39;Isaac&#39;, last: &#39;Newton&#39;, year: 1643, passed: 1727 }, { first: &#39;Galileo&#39;, last: &#39;Galilei&#39;, year: 1564, passed: 1642 }, { first: &#39;Marie&#39;, last: &#39;Curie&#39;, year: 1867, passed: 1934 }, { first: &#39;Johannes&#39;, last: &#39;Kepler&#39;, year: 1571, passed: 1630 }, { first: &#39;Nicolaus&#39;, last: &#39;Copernicus&#39;, year: 1463, passed: 1543 }, { first: &#39;Max&#39;, last: &#39;Planck&#39;, year: 1858, passed: 1947 }, { first: &#39;Katherine&#39;, last: &#39;Blodgett&#39;, year: 1898, passed: 1979 }, { first: &#39;Ada&#39;, last: &#39;Lovelace&#39;, year: 1768, passed: 1852 }, { first: &#39;Sarah E.&#39;, last: &#39;Goode&#39;, year: 1855, passed: 1905 }, { first: &#39;Lise&#39;, last: &#39;Meitner&#39;, year: 1878, passed: 1968 }, { first: &#39;Hanna&#39;, last: &#39;Hammarström&#39;, year: 1829, passed: 1909 } ];</p></li></ol><p>设计函数，输入inventors，返回值是：</p><ol><li><p>过滤出1800年后出生的人</p></li><li><p>所有人全名的集合</p></li><li><p>返回Ada和Lise被删除了的数组 (不允许改变原数组)</p></li><li><p>出生年份正序作为新顺序 (不允许改变原数组)</p></li><li><p>统计出1900年前死的人数</p></li><li><p>他们所有人寿命的平均值</p></li><li><p>把生于1800年后的人和前的人分类,返回一个新对象，形如</p><p>{</p><p>&quot;&lt;1800&quot;: [ ],</p><p>&quot;&gt;=1800&quot;: [ ]</p><p>}</p></li><li><p>按寿命归类，返回寿命为key，对应人的数组为值的对象</p></li><li><p>输入一个字符串，实现人名搜索功能，返回所有包含该字符串的对象</p></li><li><p>输入一个字符串，实现字符搜索功能（输入数字也会匹配出生死亡的年份），返回所有包含字符串的对象</p></li><li></li></ol>',42),o=[l];function n(c,d,f,_,m,h){return p(),a("div",null,o)}const b=e(i,[["render",n]]);export{y as __pageData,b as default};
